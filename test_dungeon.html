<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Test Generazione Dungeon - Crypta</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #f0e6d3; }
        .test { margin: 20px 0; padding: 10px; background: #2d2d44; border-radius: 5px; }
        .pass { color: #4caf50; }
        .fail { color: #f44336; font-weight: bold; }
        .warning { color: #ff9800; }
        .grid { display: inline-grid; gap: 2px; margin: 10px; }
        .cell { width: 30px; height: 30px; border: 1px solid #555; display: flex; align-items: center; justify-content: center; font-size: 10px; }
        button { padding: 10px 20px; margin: 10px; background: #5c4033; color: #f0e6d3; border: 2px solid #8b7355; border-radius: 5px; cursor: pointer; }
        button:hover { background: #8b6914; }
    </style>
</head>
<body>
    <h1>Test Generazione Dungeon - Crypta</h1>
    <button onclick="runTests()">Esegui Test</button>
    <button onclick="runMultipleTests()">Test Multiple (10 generazioni)</button>
    <div id="results"></div>

    <script>
        // Copia delle funzioni dal gioco
        function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}
        
        const ELEMENT_COUNTS={2:{monster:4,chest:5,key:5,sword:4,potion:5,trap:3,passage:2,sphere:2,empty:6},3:{monster:6,chest:7,key:7,sword:6,potion:6,trap:4,passage:2,sphere:2,empty:9},4:{monster:8,chest:9,key:9,sword:8,potion:7,trap:5,passage:2,sphere:2,empty:14}};
        const GRID_SIZES={2:6,3:7,4:8};

        function validateAllConstraints(grid,size,counts){
            const elements={sphere:[],passage:[],potion:[],trap:[],chest:[],key:[],sword:[],monster:[],empty:[]};
            for(let r=0;r<size;r++)for(let c=0;c<size;c++)elements[grid[r][c]].push({r,c});
            if(elements.sphere.length!==2)return{valid:false,reason:'sphere count'};
            if(elements.passage.length!==2)return{valid:false,reason:'passage count'};
            if(elements.potion.length!==counts.potion)return{valid:false,reason:'potion count'};
            if(elements.trap.length!==counts.trap)return{valid:false,reason:'trap count'};
            if(elements.chest.length!==counts.chest)return{valid:false,reason:'chest count'};
            if(elements.key.length!==counts.key)return{valid:false,reason:'key count'};
            if(elements.sword.length!==counts.sword)return{valid:false,reason:'sword count'};
            if(elements.monster.length!==counts.monster)return{valid:false,reason:'monster count'};
            if(elements.empty.length!==counts.empty)return{valid:false,reason:'empty count'};
            function isAdjacent(r1,c1,r2,c2){return Math.abs(r1-r2)<=1&&Math.abs(c1-c2)<=1&&!(r1===r2&&c1===c2)}
            const s=elements.sphere;
            if(s[0].c-s[0].r!==s[1].c-s[1].r)return{valid:false,reason:'spheres not on same diagonal'};
            const p=elements.passage;
            if(Math.abs(p[0].r-p[1].r)+Math.abs(p[0].c-p[1].c)<4)return{valid:false,reason:'passages too close'};
            const potionRows=new Set(),potionCols=new Set();
            for(const pot of elements.potion){
                if(potionRows.has(pot.r)||potionCols.has(pot.c))return{valid:false,reason:'potions in same row/col'};
                potionRows.add(pot.r);potionCols.add(pot.c);
            }
            for(const trap of elements.trap){
                if(trap.r===0||trap.r===size-1||trap.c===0||trap.c===size-1)return{valid:false,reason:'trap on edge'};
                for(const other of elements.trap){
                    if(trap!==other&&isAdjacent(trap.r,trap.c,other.r,other.c))return{valid:false,reason:'traps adjacent'};
                }
            }
            for(const chest of elements.chest){
                for(const other of elements.chest){
                    if(chest!==other&&isAdjacent(chest.r,chest.c,other.r,other.c))return{valid:false,reason:'chests adjacent'};
                }
            }
            for(const key of elements.key){
                let nearChest=false;
                for(const chest of elements.chest){
                    if(Math.max(Math.abs(key.r-chest.r),Math.abs(key.c-chest.c))<=2){nearChest=true;break}
                }
                if(!nearChest)return{valid:false,reason:'key not near chest'};
            }
            for(const sword of elements.sword){
                for(const key of elements.key){
                    if(isAdjacent(sword.r,sword.c,key.r,key.c))return{valid:false,reason:'sword adjacent to key'};
                }
            }
            for(const monster of elements.monster){
                for(const other of elements.monster){
                    if(monster!==other&&isAdjacent(monster.r,monster.c,other.r,other.c))return{valid:false,reason:'monsters adjacent'};
                }
            }
            for(const empty of elements.empty){
                let hasChest=false,hasMonster=false;
                for(let dr=-1;dr<=1;dr++){
                    for(let dc=-1;dc<=1;dc++){
                        if(dr===0&&dc===0)continue;
                        const nr=empty.r+dr,nc=empty.c+dc;
                        if(nr>=0&&nr<size&&nc>=0&&nc<size){
                            if(grid[nr][nc]==='chest')hasChest=true;
                            if(grid[nr][nc]==='monster')hasMonster=true;
                        }
                    }
                }
                if(!hasChest||!hasMonster)return{valid:false,reason:'empty not adjacent to chest and monster'};
            }
            return{valid:true};
        }

        function generateDungeon(seed,playerCount){
            let mainAttempts=0;
            const maxMainAttempts=1000;
            while(mainAttempts<maxMainAttempts){
                const random=mulberry32(seed+mainAttempts*1000000);
                const size=GRID_SIZES[playerCount];
                const grid=Array(size).fill(0).map(()=>Array(size).fill('empty'));
                const counts=ELEMENT_COUNTS[playerCount];
                function getEmptyCells(){const cells=[];for(let r=0;r<size;r++)for(let c=0;c<size;c++)if(grid[r][c]==='empty')cells.push({r,c});return cells}
                function isAdjacent(r1,c1,r2,c2){return Math.abs(r1-r2)<=1&&Math.abs(c1-c2)<=1&&!(r1===r2&&c1===c2)}
                let spherePlaced=0,attempts=0;
                while(spherePlaced<2&&attempts<1000){attempts++;const diagonal=Math.floor(random()*(2*size-1))-(size-1);const diagonalCells=[];for(let r=0;r<size;r++)for(let c=0;c<size;c++)if(c-r===diagonal&&grid[r][c]==='empty')diagonalCells.push({r,c});if(diagonalCells.length>=2){const idx1=Math.floor(random()*diagonalCells.length);let idx2;do{idx2=Math.floor(random()*diagonalCells.length)}while(idx2===idx1);grid[diagonalCells[idx1].r][diagonalCells[idx1].c]='sphere';grid[diagonalCells[idx2].r][diagonalCells[idx2].c]='sphere';spherePlaced=2}}
                if(spherePlaced<2){mainAttempts++;continue}
                let passagePlaced=0;attempts=0;const passages=[];
                while(passagePlaced<2&&attempts<1000){attempts++;const empty=getEmptyCells();if(!empty.length)break;const cell=empty[Math.floor(random()*empty.length)];if(passagePlaced===0){grid[cell.r][cell.c]='passage';passages.push(cell);passagePlaced++}else{const dist=Math.abs(cell.r-passages[0].r)+Math.abs(cell.c-passages[0].c);if(dist>=4){grid[cell.r][cell.c]='passage';passagePlaced++}}}
                if(passagePlaced<2){mainAttempts++;continue}
                const potionRows=new Set(),potionCols=new Set();let potionPlaced=0;attempts=0;
                while(potionPlaced<counts.potion&&attempts<1000){attempts++;const empty=getEmptyCells();if(!empty.length)break;const cell=empty[Math.floor(random()*empty.length)];if(!potionRows.has(cell.r)&&!potionCols.has(cell.c)){grid[cell.r][cell.c]='potion';potionRows.add(cell.r);potionCols.add(cell.c);potionPlaced++}}
                if(potionPlaced<counts.potion){mainAttempts++;continue}
                const traps=[];let trapPlaced=0;attempts=0;
                while(trapPlaced<counts.trap&&attempts<1000){attempts++;const empty=getEmptyCells();if(!empty.length)break;const cell=empty[Math.floor(random()*empty.length)];if(cell.r>0&&cell.r<size-1&&cell.c>0&&cell.c<size-1){let adjacent=false;for(const trap of traps)if(isAdjacent(cell.r,cell.c,trap.r,trap.c)){adjacent=true;break}if(!adjacent){grid[cell.r][cell.c]='trap';traps.push(cell);trapPlaced++}}}
                if(trapPlaced<counts.trap){mainAttempts++;continue}
                const chests=[];let chestPlaced=0;attempts=0;
                while(chestPlaced<counts.chest&&attempts<1000){attempts++;const empty=getEmptyCells();if(!empty.length)break;const cell=empty[Math.floor(random()*empty.length)];let adjacent=false;for(const chest of chests)if(isAdjacent(cell.r,cell.c,chest.r,chest.c)){adjacent=true;break}if(!adjacent){grid[cell.r][cell.c]='chest';chests.push(cell);chestPlaced++}}
                if(chestPlaced<counts.chest){mainAttempts++;continue}
                let keyPlaced=0;attempts=0;
                while(keyPlaced<counts.key&&attempts<1000){attempts++;const empty=getEmptyCells();if(!empty.length)break;const cell=empty[Math.floor(random()*empty.length)];for(const chest of chests){const dist=Math.max(Math.abs(cell.r-chest.r),Math.abs(cell.c-chest.c));if(dist<=2){grid[cell.r][cell.c]='key';keyPlaced++;break}}}
                if(keyPlaced<counts.key){mainAttempts++;continue}
                const keys=[];for(let r=0;r<size;r++)for(let c=0;c<size;c++)if(grid[r][c]==='key')keys.push({r,c});
                let swordPlaced=0;attempts=0;
                while(swordPlaced<counts.sword&&attempts<1000){attempts++;const empty=getEmptyCells();if(!empty.length)break;const cell=empty[Math.floor(random()*empty.length)];let adjacentToKey=false;for(const key of keys)if(isAdjacent(cell.r,cell.c,key.r,key.c)){adjacentToKey=true;break}if(!adjacentToKey){grid[cell.r][cell.c]='sword';swordPlaced++}}
                if(swordPlaced<counts.sword){mainAttempts++;continue}
                const monsters=[];let monsterPlaced=0;attempts=0;
                while(monsterPlaced<counts.monster&&attempts<1000){attempts++;const empty=getEmptyCells();if(!empty.length)break;const cell=empty[Math.floor(random()*empty.length)];let adjacent=false;for(const monster of monsters)if(isAdjacent(cell.r,cell.c,monster.r,monster.c)){adjacent=true;break}if(!adjacent){grid[cell.r][cell.c]='monster';monsters.push(cell);monsterPlaced++}}
                if(monsterPlaced<counts.monster){mainAttempts++;continue}
                const validation=validateAllConstraints(grid,size,counts);
                if(validation.valid){return {grid,size,valid:true}}
                mainAttempts++;
            }
            return {grid:null,size:0,valid:false};
        }

        function testDungeon(grid, size, playerCount) {
            const results = [];
            const counts = ELEMENT_COUNTS[playerCount];
            
            // Conta elementi
            const elementCounts = {};
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const elem = grid[r][c];
                    elementCounts[elem] = (elementCounts[elem] || 0) + 1;
                }
            }

            // Test 1: Conteggio elementi
            for (const [elem, expectedCount] of Object.entries(counts)) {
                const actualCount = elementCounts[elem] || 0;
                if (actualCount !== expectedCount) {
                    results.push({pass: false, msg: `${elem}: attesi ${expectedCount}, trovati ${actualCount}`});
                } else {
                    results.push({pass: true, msg: `${elem}: ${actualCount} ‚úì`});
                }
            }

            // Test 2: Sfere sulla stessa diagonale
            const spheres = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] === 'sphere') spheres.push({r, c});
                }
            }
            if (spheres.length === 2) {
                const diag1 = spheres[0].c - spheres[0].r;
                const diag2 = spheres[1].c - spheres[1].r;
                if (diag1 === diag2) {
                    results.push({pass: true, msg: `Sfere sulla stessa diagonale ‚úì`});
                } else {
                    results.push({pass: false, msg: `Sfere NON sulla stessa diagonale! (${spheres[0].c}-${spheres[0].r}=${diag1}, ${spheres[1].c}-${spheres[1].r}=${diag2})`});
                }
            }

            // Test 3: Passaggi distanza >= 4
            const passages = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] === 'passage') passages.push({r, c});
                }
            }
            if (passages.length === 2) {
                const dist = Math.abs(passages[0].r - passages[1].r) + Math.abs(passages[0].c - passages[1].c);
                if (dist >= 4) {
                    results.push({pass: true, msg: `Passaggi a distanza ${dist} ‚úì`});
                } else {
                    results.push({pass: false, msg: `Passaggi troppo vicini! Distanza: ${dist} (min 4)`});
                }
            }

            // Test 4: Pozioni non su stessa riga/colonna
            const potions = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] === 'potion') potions.push({r, c});
                }
            }
            let potionsFail = false;
            for (let i = 0; i < potions.length; i++) {
                for (let j = i + 1; j < potions.length; j++) {
                    if (potions[i].r === potions[j].r) {
                        results.push({pass: false, msg: `Pozioni sulla stessa riga ${potions[i].r}!`});
                        potionsFail = true;
                    }
                    if (potions[i].c === potions[j].c) {
                        results.push({pass: false, msg: `Pozioni sulla stessa colonna ${potions[i].c}!`});
                        potionsFail = true;
                    }
                }
            }
            if (!potionsFail) results.push({pass: true, msg: `Pozioni non su stessa riga/colonna ‚úì`});

            // Test 5: Trappole non sui bordi
            const traps = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] === 'trap') {
                        traps.push({r, c});
                        if (r === 0 || r === size - 1 || c === 0 || c === size - 1) {
                            results.push({pass: false, msg: `Trappola sul bordo in (${r},${c})!`});
                        }
                    }
                }
            }

            // Test 6: Trappole non adiacenti
            function isAdjacent(r1, c1, r2, c2) {
                return Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1 && !(r1 === r2 && c1 === c2);
            }
            let trapsAdjacent = false;
            for (let i = 0; i < traps.length; i++) {
                for (let j = i + 1; j < traps.length; j++) {
                    if (isAdjacent(traps[i].r, traps[i].c, traps[j].r, traps[j].c)) {
                        results.push({pass: false, msg: `Trappole adiacenti in (${traps[i].r},${traps[i].c}) e (${traps[j].r},${traps[j].c})!`});
                        trapsAdjacent = true;
                    }
                }
            }
            if (!trapsAdjacent && traps.length > 0) results.push({pass: true, msg: `Trappole non adiacenti ‚úì`});

            // Test 7: Scrigni non adiacenti
            const chests = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] === 'chest') chests.push({r, c});
                }
            }
            let chestsAdjacent = false;
            for (let i = 0; i < chests.length; i++) {
                for (let j = i + 1; j < chests.length; j++) {
                    if (isAdjacent(chests[i].r, chests[i].c, chests[j].r, chests[j].c)) {
                        results.push({pass: false, msg: `Scrigni adiacenti in (${chests[i].r},${chests[i].c}) e (${chests[j].r},${chests[j].c})!`});
                        chestsAdjacent = true;
                    }
                }
            }
            if (!chestsAdjacent && chests.length > 0) results.push({pass: true, msg: `Scrigni non adiacenti ‚úì`});

            // Test 8: Mostri non adiacenti
            const monsters = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] === 'monster') monsters.push({r, c});
                }
            }
            let monstersAdjacent = false;
            for (let i = 0; i < monsters.length; i++) {
                for (let j = i + 1; j < monsters.length; j++) {
                    if (isAdjacent(monsters[i].r, monsters[i].c, monsters[j].r, monsters[j].c)) {
                        results.push({pass: false, msg: `Mostri adiacenti in (${monsters[i].r},${monsters[i].c}) e (${monsters[j].r},${monsters[j].c})!`});
                        monstersAdjacent = true;
                    }
                }
            }
            if (!monstersAdjacent && monsters.length > 0) results.push({pass: true, msg: `Mostri non adiacenti ‚úì`});

            // Test 9: Chiavi entro distanza 2 da almeno uno scrigno
            const keys = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] === 'key') keys.push({r, c});
                }
            }
            for (const key of keys) {
                let nearChest = false;
                for (const chest of chests) {
                    const dist = Math.max(Math.abs(key.r - chest.r), Math.abs(key.c - chest.c));
                    if (dist <= 2) {
                        nearChest = true;
                        break;
                    }
                }
                if (!nearChest) {
                    results.push({pass: false, msg: `Chiave in (${key.r},${key.c}) troppo lontana da tutti gli scrigni! (max distanza 2)`});
                }
            }

            // Test 10: Spade non adiacenti a chiavi
            const swords = [];
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] === 'sword') swords.push({r, c});
                }
            }
            let swordKeyAdjacent = false;
            for (const sword of swords) {
                for (const key of keys) {
                    if (isAdjacent(sword.r, sword.c, key.r, key.c)) {
                        results.push({pass: false, msg: `Spada in (${sword.r},${sword.c}) adiacente a chiave in (${key.r},${key.c})!`});
                        swordKeyAdjacent = true;
                    }
                }
            }
            if (!swordKeyAdjacent && swords.length > 0 && keys.length > 0) results.push({pass: true, msg: `Spade non adiacenti a chiavi ‚úì`});

            // Test 11: Ogni spazio vuoto √® adiacente sia a uno scrigno sia a un mostro
            let emptyFail = false;
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] === 'empty') {
                        let hasChest = false;
                        let hasMonster = false;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < size && nc >= 0 && nc < size) {
                                    if (grid[nr][nc] === 'chest') hasChest = true;
                                    if (grid[nr][nc] === 'monster') hasMonster = true;
                                }
                            }
                        }
                        if (!hasChest || !hasMonster) {
                            results.push({pass: false, msg: `Spazio vuoto in (${r},${c}) non √® adiacente a ${!hasChest ? 'scrigno' : 'mostro'}!`});
                            emptyFail = true;
                        }
                    }
                }
            }
            if (!emptyFail && elementCounts['empty'] > 0) results.push({pass: true, msg: `Ogni spazio vuoto adiacente a scrigno E mostro ‚úì`});

            return results;
        }

        function displayGrid(grid, size) {
            const symbols = {
                monster: 'üëπ',
                chest: 'üì¶',
                key: 'üîë',
                sword: '‚öîÔ∏è',
                potion: 'üß™',
                trap: '‚ö†Ô∏è',
                passage: 'üö™',
                sphere: 'üîÆ',
                empty: '¬∑'
            };
            
            let html = `<div class="grid" style="grid-template-columns: repeat(${size}, 30px);">`;
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const elem = grid[r][c];
                    html += `<div class="cell" title="${elem} (${r},${c})">${symbols[elem]}</div>`;
                }
            }
            html += '</div>';
            return html;
        }

        function runTests() {
            const seed = Math.floor(Math.random() * 1000000);
            const playerCount = 4; // Test con 4 giocatori

            const result = generateDungeon(seed, playerCount);

            let html = `<div class="test">`;
            html += `<h2>Test Seed: ${seed} (${playerCount} giocatori)</h2>`;

            if (!result.valid || !result.grid) {
                html += `<div class="fail">‚ùå Generazione fallita! Impossibile creare dungeon valido.</div>`;
                html += `</div>`;
                document.getElementById('results').innerHTML = html;
                return;
            }

            const {grid, size} = result;
            html += `<div class="pass">‚úÖ Generazione riuscita con validazione completa</div>`;
            html += displayGrid(grid, size);

            const testResults = testDungeon(grid, size, playerCount);
            html += `<div style="margin-top: 20px;">`;

            let passed = 0;
            let failed = 0;
            for (const r of testResults) {
                const className = r.pass ? 'pass' : 'fail';
                html += `<div class="${className}">‚Ä¢ ${r.msg}</div>`;
                if (r.pass) passed++;
                else failed++;
            }

            html += `</div>`;
            html += `<div style="margin-top: 20px; font-weight: bold;">Totale: ${passed} passati, ${failed} falliti</div>`;
            html += `</div>`;

            document.getElementById('results').innerHTML = html;
        }

        function runMultipleTests() {
            let html = '<div class="test"><h2>Test Multipli (10 generazioni casuali)</h2>';
            let totalSuccess = 0;
            let totalFail = 0;

            for (let i = 0; i < 10; i++) {
                const seed = Math.floor(Math.random() * 1000000);
                const playerCount = [2, 3, 4][Math.floor(Math.random() * 3)];

                const result = generateDungeon(seed, playerCount);

                if (!result.valid || !result.grid) {
                    html += `<div class="fail">Test ${i+1} - Seed: ${seed} (${playerCount} giocatori) - ‚ùå Generazione fallita!</div>`;
                    totalFail++;
                    continue;
                }

                const {grid, size} = result;
                const testResults = testDungeon(grid, size, playerCount);

                const failed = testResults.filter(r => !r.pass).length;
                const status = failed === 0 ? 'pass' : 'fail';

                if (failed === 0) {
                    totalSuccess++;
                    html += `<div class="${status}">Test ${i+1} - Seed: ${seed} (${playerCount} giocatori) - ‚úÖ OK (tutti i vincoli rispettati)</div>`;
                } else {
                    totalFail++;
                    html += `<div class="${status}">Test ${i+1} - Seed: ${seed} (${playerCount} giocatori) - ‚ùå ${failed} errori</div>`;
                    html += displayGrid(grid, size);
                    for (const r of testResults) {
                        if (!r.pass) {
                            html += `<div class="fail" style="margin-left: 20px;">  ‚Ä¢ ${r.msg}</div>`;
                        }
                    }
                }
            }

            html += `<div style="margin-top: 20px; font-weight: bold; font-size: 1.2em;">Riepilogo: ${totalSuccess}/10 generazioni valide</div>`;
            html += '</div>';
            document.getElementById('results').innerHTML = html;
        }
    </script>
</body>
</html>
